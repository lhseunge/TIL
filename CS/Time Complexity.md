# 시간복잡도 (Time Complexity)

# I. 시간복잡도

입력값과 연산 수행 시간의 상관관계를 나타내는 척도

# II. 시간복잡도 표현 방법

- 최상의 경우 - 오메가 표기법 (Big Ω Notation)
- 평균의 경우 - 세타 표기법 (Big Θ Notation)
- 최악의 경우 - 빅 오 표기법 (Big O Notation)

시간복잡도는 ‘최악’을 기준으로 빅 오 표기법으로 판단하여 성능을 예측한다. 

## 1. 데이터 원소 N개에 대한 알고리즘의 단계 수

데이터가 늘어날 때 단계 수가 어떻게 증가하는가를 의미한다. 

### **O(3) == O(100) == O(1)**

> 데이터가 몇 개든 항상 3단계가 걸리는 알고리즘
**→ 원소가 N개일 때 알고리즘에 항상 3단계가 필요하다.**
이를 빅 오 표기법으로 어떻게 표현할까

O(3)? O(1)?

**정답은 O(1) 이다.** 
이유는 빅 오 표기법이 알고리즘에 필요한 단계 수를 알려주는 것 말고도 한 가지 더 역할을 한다는 것에 있다.
> 

빅 오 표기법은 단순히 알고리즘에 필요한 단계 수 뿐만 아니라, 
→ **데이터가 늘어날 때 알고리즘의 단계 수가 어떻게 증가하는지, 성능이 어떻게 바뀌는지도 설명한다.**

O(3), O(1) 모두 데이터 증가에 영향을 받지 않는 알고리즘 유형이다. 

N이 얼마든 항상 상수 단계만 필요하다.

그래서 O(1) 알고리즘을 상수시간 `Constant Time` 을 갖는 알고리즘이라고도 표현한다.

### O(1)과 O(N)에서 데이터 변화가 미치는 과정

- O(1)은 데이터 증감에 영향을 받지 않는다.
- O(N) 알고리즘은 데이터의 증가가 성능에 영향을 미친다.
- 데이터가 늘어날 때 정확히 그 데이터에 비례해 단계 수가 증가한다.
- 알고리즘의 효율성과 데이터가 비례 관계이다.

### O(1) & O(N) 그래프

![image.png](attachment:df120830-50d4-4dfd-bdce-68bb480192d0:image.png)

| O(N) | O(1)  |
| --- | --- |
| 완벽한 대각선을 그린다.  | 완벽한 수평선을 그린다.  |
| 데이터가 추가될 때마다 알고리즘도 비례해서 더 걸린다. | 데이터의 증감에 영향을 받지 않고 단계 수가 일정하다. |

## 최악의 시나리오

> 선형 검색이 항상 O(N)은 아니다.
> 
> 
> 검색값이 배열의 맨 처음에 있는 최선의 시나리오에서는 O(1)이고
> 
> 검색값이 배열의 맨 끝에 있는 최악의 시나리오에서는 O(N)이다.
> 

빅 오 표기법은 일반적으로 최악의 시나리오를 의미한다. 

최악의 시나리오에서 알고리즘이 얼마나 비효율적인지 정확히 알면 최악을 대비함과 동시에 알고리즘의 선택에 중요한 영향을 미칠 수 있기 때문이다.

# O(N)

데이터 원소가 N개일 때 N단계가 걸리는 알고리즘이다. 

데이터가 늘어날 때 데이터와 비례해 단계 수가 증가하는 알고리즘이다. 

```
배열의 원소가 N개 일 때 선형 검색에 몇 단계가 필요할까?

배열에 N개의 원소가 있을 때 선형 검색에 N단계가 필요하다. 
// 선형탐색이란? : 데이터의 집합에서 처음부터 끝까지 하나씩 비교하며 원하는 값을 찾는 알고리즘
```
